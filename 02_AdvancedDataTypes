#######################################################################
Type: List
# Use:
  Used for storing similar items, and in case where items need to be added or removed
# Creation
  [] or list() for empty list, or [1,2,3] for a list with items
# Search Methods
  my_list.index(item) or item in my_list
# Search Speed
  Searching for an item in a large list is slow. Each item must be checked
# Common Methods
  len(my_list), append(item) to add, insert(index, item) to insert in the middle, pop() to remove
# Order preserved?
  Yes - items can be accessed by index
# Mutable?
  Yes
# In-place sortable?
  Yes - my_list.sort() or my_list.reverse() will sort the list in-place


>>> # Lists
>>> []
[]
>>> list()
[]
>>> type ([]) 
<class 'list'>
>>> names = ["Sara", "Max", "Rose"]
>>> type(names)
<class 'list'>
>>> names
['Sara', 'Max', 'Rose']
>>> print(names)
['Sara', 'Max', 'Rose']
>>> "Sara".lower()
'sara'
>>> len(names)
3   
>>> names[1]
'Max'
>>> names[]
  File "<stdin>", line 1   
    names[]
          ^
SyntaxError: invalid syntax
>>> names[0] 
'Sara'
>>> names[2]
'Rose'
>>> names[4]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list index out of range
>>> names
['Sara', 'Max', 'Rose']
>>> names[1] = "Jimmy"
>>> names
['Sara', 'Jimmy', 'Rose']
>>> names = [
... "Sara",
... "Jimmy",
... "Rose",
... ]
>>> names
['Sara', 'Jimmy', 'Rose']
>>> [1, 2, 3 4]
  File "<stdin>", line 1
    [1, 2, 3 4]
             ^
SyntaxError: invalid syntax
>>> lottery_numbers = [1, 4, 2374, 90, 14, 7]
>>> # Two ways of sorting in python
>>> sorted(lottery_numbers)
[1, 4, 7, 14, 90, 2374]
>>> lottery_numbers
[1, 4, 2374, 90, 14, 7]
>>> sorted(lottery_numbers, reverse =True)
[2374, 90, 14, 7, 4, 1]
>>> lottery_numbers
[1, 4, 2374, 90, 14, 7]
>>> x = sorted(lottery_numbers)
>>> x
[1, 4, 7, 14, 90, 2374]
>>> # Second way of sorting lists in Python
>>> # Your data is going to change
>>> lottery_numbers.sort()
>>> lottery_numbers
[1, 4, 7, 14, 90, 2374]
>>> lottery_numbers.reverse()
>>> lottery_numbers
[2374, 90, 14, 7, 4, 1]
>>> type(lottery_numbers)
<class 'list'>
>>> dir(list)
['__add__', '__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', 
'__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']
>>> help(list.reverse)
Help on method_descriptor:

reverse(self, /)
    Reverse *IN PLACE*.

>>> len(lottery_numbers)
6
>>> names = ["Sara", "Alex"]
>>> names.append("Jimmy")
>>> names
['Sara', 'Alex', 'Jimmy']
>>> len(names)
3
>>> # insert into list -- my_list(position, value)
>>> names.insert(0, "Rose")
>>> names
['Rose', 'Sara', 'Alex', 'Jimmy']
>>> help(list.insert)
Help on method_descriptor:

insert(self, index, object, /)
    Insert object before index.

>>> names = ["Sara", "Alex"]
>>> colors = ["Red", "Blue"]
>>> names.extend(colors)
>>> names
['Sara', 'Alex', 'Red', 'Blue']
>>> names = ["Sara", "Phil", "Alex", "Sara"]
>>> # Check to see if a value is present in a list or not
>>> "Rose" in names
False
>>>
>>> "Sara" in names
True
>>> names.index("Phil") 
1
>>> names.index("Sara")
0
>>> names.count("Phil")
1
>>> names.count("Sara")
2
>>> names[0]  = "Jimmy" 
>>> names
['Jimmy', 'Phil', 'Alex', 'Sara']
>>> pos = names.index("Phil")
>>> names[pos] = "Floyd"
>>> names
['Jimmy', 'Floyd', 'Alex', 'Sara']
>>> len(names)
4
>>> names[4]= "Paul"
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: list assignment index out of range
>>> names = ["Sara", "Alex"] 
>>> names.remove("Alex")
>>> names
['Sara']
>>> names = ["Sara", "Alex", "Pam", "Alex"]
>>> names.remove("Alex")
>>> names
['Sara', 'Pam', 'Alex']
>>> names.remove("Jacob")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: list.remove(x): x not in list
>>> names
['Sara', 'Pam', 'Alex']
>>> names.pop()
'Alex'
>>> names
['Sara', 'Pam']
>>> # pop() removes the last index in the list
>>> names = ["Sara", "Alex", "Pam"]        
>>> names.pop(1)
'Alex'
>>> names
['Sara', 'Pam']
>>> # pop() can also take in an index to remove     
>>> names
['Sara', 'Pam']
>>> len(names)
2
>>>

#######################################################################

Type: Tuple
# Use:
  Used for storing a snapshot of realted items when we don't plan on modifying, adding, or removing data
# Creation
  () or tuple() for empty tuple, (1, ) for one item, or (1,2,3) for a tuple with items
# Search Methods
  my_tuple.index(item) or item in my_tuple
# Search Speed
  Searching for an item in a large list is slow. Each item must be checked
# Common Methods
  Can't add or remove from tuples
# Order preserved?
  Yes - items can be accessed by index
# Mutable?
  No
# In-place sortable?
  No
 

 >>> # Tuples
>>> a =()
>>> type(a)
<class 'tuple'>
>>> b = (1)
>>> type(b)
<class 'int'>
>>> c = (1,)
>>> type(c)
<class 'tuple'>
>>> # (,) is a syntax error in python
>>> (1,2,3,4,5)
(1, 2, 3, 4, 5)
>>> student = ("Marcy", 8, "History", 3.5)
>>> student[0]
'Marcy'
>>> student[1]
8   
>>> student[0] = "Sara"
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
>>> student
('Marcy', 8, 'History', 3.5)
>>> name, age, subject, gpa = student
>>> name
'Marcy'
>>> age
8   
>>> subject
'History'
>>> gpa  
3.5 
>>> # if this was a row in a spreadsheet, we could access the values quickly and easily
>>> foo, bar, baz = student
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: too many values to unpack (expected 3)
>>> name, age, subject, _ = student
>>> # underscore means throwaway this value, I don't care about it
>>> x = 1,2,3
>>> type(x)
<class 'tuple'>
>>> def http_status_code():
...     return 200, "OK"
... 
>>> http_status_code()
(200, 'OK')
>>> code, name = http_status_code()
>>> code
200
>>> name
'OK'
>>>

#######################################################################

Type: Sets
# Use:
  Used for storing immutable data types uniquely. Easy to compare the items in sets
# Creation
  set() for an empty set ({} makes an empty dictionary) and {1,2,3} for a set with items in it
# Search Methods
  item in my_set
# Search Speed
  Searching for an item in a large set is very fast
# Common Methods
  my_set.add(item), my_set.discard(item) to remove the item if it's present, my_set.update(other_set)
# Order preserved?
  No - items can't be accessed by index
# Mutable?
  Yes - you can add to or remove from sets
# In-place sortable?
  No because items aren't ordered
  

>>> # Sets
>>> type({})
<class 'dict'>
>>> set()
set()
>>> {1}
{1} 
>>> type({1})
<class 'set'>
>>> names = {"Sara", "Max", "Sara"}
>>> names
{'Sara', 'Max'}
>>> # since lists don't store duplicate values, the duplicate value gets ignored
>>> len(names)
2   
>>> # Lets' check for some hashes
>>> hash("Sara")
1946758148
>>> hash([])
Traceback (most recent call last):   
  File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'list'   
>>> {[]}
Traceback (most recent call last):   
  File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'list'   
>>> # You can only put immutable items in the set
>>> names = ["Sara", "Shane", "Alex", "Alex", "Sara"]
>>> set(names)
{'Alex', 'Sara', 'Shane'}
>>> # By passing a list into a set function, you can return a set of unique values. The items in the list are case sensitive
>>> my_set = {1, "a", 2, "b", "cat"} 
>>> my_set
{1, 2, 'cat', 'a', 'b'}
>>> my_set[0]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'set' object is not subscriptable
>>> # Adding and removing from sets
>>> colors = {"Red", "Green", "Blue"}
>>> colors.add("Pink")
>>> colors
{'Blue', 'Red', 'Green', 'Pink'}
>>> colors.discard("Green")
>>> colors
{'Blue', 'Red', 'Pink'}
>>> colors.discard("Zebra")
>>> # If you try to discard an item that isn't in the set, you won't get an error and sometimes that can be useful
>>> colors.remove("Pink")
>>> colors
{'Blue', 'Red'}
>>> colors.remove("Pink")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 'Pink'
>>> colors
{'Blue', 'Red'}
>>> numbers = {1,4,5}
>>> colors.update(numbers)
>>> colors
{'Blue', 1, 'Red', 4, 5}
>>> colors.update("Sara")
>>> colors
{'Blue', 1, 'Red', 4, 5, 'a', 'S', 'r'}
>>> # The update function expects a sequence and if you pass in a string it will look for a sequence under the hood
>>> # Set Operations
>>> colors = {"Red", "Green", "Blue"}
>>> "Blue" in colors
True
>>> "Orange" in colors
False
>>> rainbow_colors = {"Red", "Orange", "Yellow", "Green", "Blue", "Violet"}
>>> favorite_colors = {"Blue", "Purple", "Gray"}
>>> rainbow_colors
{'Red', 'Green', 'Violet', 'Blue', 'Orange', 'Yellow'}
>>> favorite_colors
{'Blue', 'Gray', 'Purple'}
>>> # my_set.union(other_set) OR my_set | other_set
>>> rainbow_colors | favorite_colors
{'Red', 'Green', 'Violet', 'Blue', 'Purple', 'Gray', 'Orange', 'Yellow'}
>>> # rainbow_colors & favorite_colors for intersection
>>> rainbow_colors & favorite_colors 
{'Blue'}
>>> # All items in one set but not in the other set
>>> rainbow_colors ^ favorite_colors
{'Red', 'Green', 'Violet', 'Purple', 'Gray', 'Orange', 'Yellow'}
>>>

#######################################################################

Type: Dictionaries
# Use:
  Used for storing data in key, value pairs. Keys used must be immutable data types
# Creation
  {} or dict() for an empty dict. {1: "one", 2: "two"} for a dict with items
# Search Methods
  key in my_dict()
# Search Speed
  Searching for a key in a large dictionary is fast
# Common Methods
  my_dict[key] to get the value by key and throw a KeyError if key is not in the dictionary. Use my_dict.get(key) to fall silently if key is not in my_dict. my_dict_items() for all key, value pairs, my_dict.keys() for all keys, and my_dict.values() for all values
# Order preserved?
  Sort of. As of Python 3.6 a dict is sorted by insertion order. Items can't be accessed by index, only by key
# Mutable?
  Yes. You can add or remove keys from dict's
# In-place sortable?
  No. dict's don't have an index, only keys

